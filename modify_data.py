import os
import csv
import random
import matplotlib.pyplot as plt

#======================================================================
#================    READ, COMPILE, OUTPUT CSV   ======================
#======================================================================
"""
INPUT: file_path: str -> The path to the file to read the data from
OUTPUT: records: list -> The data of the students

records = [student1, student2, student3, ...]

In this function we do:
- Open the file based on the (file_path)
- Use csv library to extract the data row by row
- For each row / student, we do:
    - Change the student's (CGPA) into (float type)
    - Append the student into (records)

Each student will be represented like this -> {"Tutorial Group": _, "Student ID": _, "Name": _, "School": _, "Gender": _, "CGPA": _}
"""

def read_student_data(file_path="records.csv"): # opens file called records.csv
    records = [] #generates empty list
    try:
        with open(file_path, mode='r', newline='') as file:
            reader = csv.DictReader(file)
            for row in reader: 
                row['CGPA'] = float(row['CGPA'])#changes cgpa data type from str to flt, so we can iterate on it
                records.append(row)#puts the list into the records list, creating list of lists
    except FileNotFoundError:
        print(f"Error: The file {file_path} was not found.")#handles situation where file is gone
        return None
    return records

"""
INPUT: student_data:list -> The data containing the students
OUTPUT: tutorial_groups: dict -> The data generated by separating the students based on their tutorial groups

tutorial_groups = {"G-1": [student1, student2, ...], "G-2": [student1, student2, ...], ...}

In this function we do:
- Read each student from (student_data)
- Extract their tutorial group (tg) 
- Check if (tg) is inside (tutorial_groups)
- Assign the student based on their (tg)
"""

def students_by_tg(student_data): #reads the output list of list from the previous function
    tutorial_groups = {} #empty dict
    for student in student_data:
        tg = student["Tutorial Group"] #initialising tg variable to the tg of indv students
        if tg not in tutorial_groups: 
            tutorial_groups[tg] = [] #creates new tg if not already present
        tutorial_groups[tg].append(student) #adds the student to their tg
    return tutorial_groups

"""
INPUT: final_student_list: list -> The data containing the students
       output_path: str -> The filename for outputting the data

In this function we do:
- Check if (final_student_list) is empty to avoid error
- Initialise the (headers) same as "records.csv" file
- Initialise (output_data) 
- Use csv library to write the data into (output_path)
"""

def write_output_csv(final_student_list, output_path="final_teams.csv"):
    if not final_student_list:
        print("No data available to write.") #incase of faulty inputs
        return
    
    headers = ["Tutorial Group", "Student ID", "Name", "School", "Gender", "CGPA"] #initialise the headers
    
    output_data = [{header: student.get(header) for header in headers} for student in final_student_list]

    with open(output_path, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=headers)
        writer.writeheader()
        writer.writerows(output_data) #write file
    print(f"Successfully created GPA-optimized allocation file: {output_path}")

#======================================================================
#================            MODIFY CSV          ======================
#======================================================================

"""
INPUT: students: list -> The student data
       variation: float -> The variation that is desired
OUTPUT: students: list -> The modified student data

In this function we do:
- Intialise the (mean), (sd), (outlier_chance)
- For each student we do:
    - Based on (outlier_chance), decide if the student is an outlier or not:
        - If the student is an outlier use a 50/50 chance to assign the student into the lower or upper outlier
        - If the student is not an outlier then assign the student's CGPA based on the spread of the data (sd)

The generated data will be "similar" to a normal distribution.
Maximum (sd) = 2.5 as Maximum variance of a dataset bounded by [0, 5] is 25/4.

In [0, 5] dataset, we categorize the outliers by setting their 2 <= (abs(sd)) <= 2.5.
"""


def modifyCGPA(students, variation): 
    mean = 2.5 # DO NOT CHANGE PLEASE
    sd = 0.1 + 1.9 * variation
    outlier_chance = 0.1 + 0.9 * variation

    for student in students:
        #On a dataset with its data bounded by [0, 5], the max sd = 2.5
        if (random.random() < outlier_chance): #Generate outliers by chance
            if (random.random() < 0.5): #Lower outliers
                student["CGPA"] =  round(random.uniform(-2.5, -2) + mean, 2)
            else: #Uppers outliers
                student["CGPA"] = round(random.uniform(2, 2.5) + mean, 2)
            
        else: #Generate data with standard deviation of the range [-sd, sd]
            student["CGPA"] = round(random.uniform(-sd, sd) + mean, 2) 

    return students

"""
INPUT: students: list -> The student data
       variation: float -> The variation that is desired
OUTPUT: students: list -> The modified student data

In this function we do:
- Intialize (number_of_students), (dominant_gender), (dominant_count), and (gender)
- Insert (dominant_count) of (dominant_gender) into (gender)
- Identitify the non-dominant gender
- Add the remaining non-dominant gender to (gender)
- Assign randomized (gender) into the (students)

We pick (dominant_gender) as the first student's gender.
(dominant_count) is generated from [25, 50].
"""

def modifyGender(students, variation):   
    number_of_students = len(students)

    dominant_gender = students[0]["Gender"]
    dominant_count = int(number_of_students // 2 * min(1 + random.uniform(0.95, 1.05) * variation, 2))

    gender = [] 
    for i in range(0, dominant_count):
        gender.append(dominant_gender) #Generate `dominant_count` of the dominant gender

    other_gender = "Female" if dominant_gender == "Male" else "Male" 
    for i in range(0, number_of_students - dominant_count):
        gender.append(other_gender) #Add the remaining non-dominant gender

    random.shuffle(gender)
    for i in range(0, number_of_students):
        students[i]["Gender"] = gender[i] #Assign the generated genders to the students]

    return students

"""
INPUT: students: list -> The student data
       variation: float -> The variation that is desired
OUTPUT: students: list -> The modified student data

In this function we do:
- Initialize (number_of_students)
- Identify the schools inside a tutorial group
- Initialize (dominant_school) and (dominant_count)
- Insert (dominant_count) of (dominant_school) into (schools)
- Add the remaining schools into (schools)
- Assign randomized (schools) into the (students)

We pick the (dominant_school) as the first student's school.
(dominant_count) range is generated from [1, 50].

However, even though (dominant_school) might not be the dominant one, 
there will always be at least (len(students) / len(schools_list)) number of the "dominant school"
"""

def modifySchool(students, variation): 
    number_of_students = len(students)

    schools_list = []
    for student in students:
        if (student["School"] not in schools_list): schools_list.append(student["School"])

    dominant_school = schools_list[0]
    dominant_count = int(min(random.uniform(0.95, 1.05) * variation * number_of_students, number_of_students))
    
    schools = []
    for i in range(0, dominant_count):
        schools.append(dominant_school) #Generate the dominant school 
    schools_list.pop(0)

    for i in range(0, number_of_students - dominant_count):
        schools.append(random.choice(schools_list)) #Add the remaining schools

    random.shuffle(schools)
    for i in range(0, number_of_students):
        students[i]["School"] = schools[i] #Assign the generated schools to the students

    return students

#======================================================================
#==================       PLOTS AND ANALYSIS      =====================
#======================================================================


"""
INPUT: students: list -> The student data
OUTPUT: variance: float -> The variance of the data

This function calculates the variance of the students' CGPA based on the formula
                variance = sum(x - mean)^2 / N
where 
    x -> individual cgpa
    mean -> average cgpa
    N -> number of data
"""

def total_cgpa_variance(students):
    overall_average = sum(s['CGPA'] for s in students) / len(students) #calculate the average cgpa of the students
    
    variance = sum((s['CGPA'] - overall_average) ** 2 for s in students) / len(students) #calculates the variance of the average tg (standard s^2 variance)
    return variance

"""
INPUT: students: list -> The student data
OUTPUT: abs(score): int -> The gender score

This function calculates the gender score which is the difference between the number of males and females.
"""

def gender_score(students): #grades how diverse each group is(lower better)
    score = 0
    for student in students:
        if (student["Gender"] == "Male"): score += 1
        else: score -= 1

    return abs(score)

"""
INPUT: students: list -> The student data
OUTPUT: score: int -> The school score

This function calculates the school score, which is calculated by (the number of each schools - 2) * 10, 
whenever there is a duplicate of the same school (school >= 2)
"""

def school_score(students): #grades how diverse each group is(lower better)
    score = 0
    school_counts = {}

    for student in students:
        school_counts[student['School']] = school_counts.get(student['School'], 0) + 1

    for count in school_counts.values():
        if count >= 2:
            score += (count - 2) * 10 #every 2nd person onwards of the same school will add 10 to the diversity score

    return score

"""
INPUT: tutorial_groups: dict -> The student data separated by their tutorial groups
       out_path: str -> The output filename to draw the graph on

In this function we do:
- Count the (cgpa) score, (gender) score, and (school) score
- Append the scores into arrays based while calculating their "variance" percentage
- Initialize 3 separate graphs
- Draw the visualization of the "variance" of the scores in 3 separate graphs
- Save the graph into (out_path)

The "variance" percentage for each category is calculated by:
- CGPA: (cgpa) / (max_variance) * 100, where (max_variance) = 25/4 in [0, 5] dataset
- Gender: (gender) / (max_score) * 100, where (max_score) = 50
- School: (school) / (max_score) * 100, where (max_score) = 480
"""

def plotGraph(tutorial_groups, out_path):
    data1, data2, data3 = [], [], []
    for tg, students in tutorial_groups.items():
        cgpa = total_cgpa_variance(students)
        gender = gender_score(students)
        school = school_score(students)

        #Percentage of CGPA variance (Maximum variance for a [0, 5] dataset = 25/4)
        data1.append(cgpa / (25 / 4) * 100)
        data2.append(gender / 50 * 100)
        data3.append(school / 480 * 100)

    fig, axis = plt.subplots(3)

    #CGPA
    axis[0].plot(data1, color = "red")
    axis[0].set_title("CGPA")
    axis[0].set_yticks([0, 25, 50, 75, 100])
    axis[0].set_ylabel("%")

    #GENDER
    axis[1].plot(data2, ",-g")
    axis[1].set_title("GENDER")
    axis[1].set_yticks([0, 25, 50, 75, 100])
    axis[1].set_ylabel("%")

    #SCHOOLS
    axis[2].plot(data3, ",-b")
    axis[2].set_title("SCHOOLS")
    axis[2].set_yticks([0, 25, 50, 75, 100])
    axis[2].set_ylabel("%")

    plt.tight_layout() # Tidy up the graph
    plt.savefig(out_path)

#======================================================================
#=========================      MAIN      =============================
#======================================================================

"""
- Read the datas contained in "records.csv" (The actual data)
- Separate the students by their Tutorial Groups
"""

records = read_student_data("records.csv")
tutorial_groups = students_by_tg(records)

"""
For each tutorial groups do:
- Modify their CGPA, Gender, School based on the variation
- Add them to "student_list" for writing into "records.modified.csv"
"""

count = 1
student_list = []
for tg, students in tutorial_groups.items():
    variation = count / 120

    tutorial_groups[tg] = modifyCGPA(students, variation)
    tutorial_groups[tg] = modifyGender(students, variation)
    tutorial_groups[tg] = modifySchool(students, variation)

    count += 1

    for student in students:
        student_list.append(student)

"""
After modifying the data, we do:
- Write out the modified data (student_list) into "records.modified.csv"
- Plot an analysis graph of the modified data
"""

write_output_csv(student_list, "records_modified.csv")
plotGraph(tutorial_groups, os.path.join("Mixed.png"))
